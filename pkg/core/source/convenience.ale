;;;; ale core: some conveniences

(define null '())
(define true #t)
(define false #f)
(define Î» lambda)

(define first car)
(define rest cdr)

(private* make-comparator)
(define* make-comparator (macro* (lambda (f r inst)
  (apply list (concat!
    '(ale/asm*
         .private prev :val
         .resolve) [f] '(
         store prev
         .private rest :val
         .resolve) [r] '(
         store rest
     :loop
         load rest
         empty
         cond-jump :success
         load prev
         load rest
         car
         ) [inst] '(
         cond-jump :next
         false
         jump :end
     :next
         load rest
         dup
         car
         store prev
         cdr
         store rest
         jump :loop
     :success
         true
     :end))))))

(define (eq f . r)
  (make-comparator f r eq))

(define (!eq f . r)
  (asm* .eval (make-comparator f r eq) not))

(define (not value)
  (if value false true))

(define-macro (!and . clauses)
  `(not (and ,@clauses)))

(define-macro (!or . clauses)
  `(not (or ,@clauses)))

(define (no-op . _) null)

(define (identity value) value)

(define (constantly value)
  (lambda _ value))

(define (is-a type value)
  ((is-a* type) value))

(define-macro (: target method . args)
  `((get ,target ,method) ,@args))
